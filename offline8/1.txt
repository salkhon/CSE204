# include <iostream>
# include <vector>
# include <algorithm>
# include <math.h>
# include <limits>
# include "Point.hpp"

using PointPair = std::vector<Point>; // array containing 2 points. 
const int UNINITIALIZED = std::numeric_limits<int>::max();

// instead of returning the closest from each recursion, the closest two will be updated
// strip width will be determined from the closest_two array at the end of each recursion

/*
Divide and Conquer closest pair finding algorithm. O(n lgn)
Can also be used to find closest two pairs.
1. Presort the array of points in two arrays, on the basis of increasing x, and another y coordinate.
2. Recurse on the x sorted array, pass in the y sorted array as well, including the boundaries.
    3. If on recursion, the size of the subset of points is <= 3, find closest pair of points comparing all combinations.
    4. Else, partition the points (sorted on x) on the mid point. Linearly partition the y sorted array, such that the points
    in xL are also in yL, points in xR are in yR, but yL and yR is sorted. (Linear time by using the presort of y on the basis of
    mid.x. NO COORDINATE X OR Y CAN MATCH FOR THIS TO WORK UNAMBIGUOUSLY).
    5. Recurse further by parting on [0, mid), [mid, hi].
    6. Using the solutions from both half, make a strip and find if any closer points reside on the strip in increasing y order.
*/

std::vector<PointPair> closest_two_pairs(2);

int dist_between_sq(const PointPair& pair) {
    return Point::dist_between_sq(pair[0], pair[1]);
}

bool _is_updating_first_time(const PointPair& pair) {
    return pair[0].x == UNINITIALIZED; // initial points set to max.
}

void _update_closest_two(const Point& p1, const Point& p2) {
    int distsq = Point::dist_between_sq(p1, p2);

    std::cout << "checking points " << p1 << " " << p2 << std::endl;
    if (_is_updating_first_time(closest_two_pairs[0]) ||
        distsq < dist_between_sq(closest_two_pairs[0])) {

        std::cout << "updating max to " << p1 << " " << p2 << std::endl;
        closest_two_pairs[1] = closest_two_pairs[0];
        closest_two_pairs[0] = PointPair{ p1, p2 };
    } else if (distsq != dist_between_sq(closest_two_pairs[0]) &&
        (_is_updating_first_time(closest_two_pairs[1]) || distsq < dist_between_sq(closest_two_pairs[1]))) {

        // don't update when the dist is equal to the closest one
        std::cout << "updating 2nd max to " << p1 << " " << p2 << std::endl;
        closest_two_pairs[1] = PointPair{ p1, p2 };
    }
}

void _do_bruteforce(int lo, int hi, const std::vector<Point>& points) {
    // hi - lo <= 3, so const time.
    // if (hi - lo < 2) {
    //     std::cout << "problem " << hi - lo << std::endl;
    // }
    for (int i = lo; i < hi - 1; i++) {
        for (int j = i + 1; j < hi; j++) {
            _update_closest_two(points[i], points[j]);
        }
    }
}

std::vector<Point> _partition(int lo, int hi, const Point& midpoint,
    const std::vector<Point>& ysorted) {
        
    std::vector<Point> partioned(ysorted.size());

    int ptrl = lo, ptrr = (lo + hi) / 2 + 1;
    for (int i = lo; i < hi; i++) {
        if (ysorted[i].x <= midpoint.x) {
            // midpoint.x needs to be unique, points equal to mid.x could be on xr, but will be put on yl.
            partioned[ptrl++] = ysorted[i];
        } else {
            partioned[ptrr++] = ysorted[i];
        }
    }

    return partioned;
}

void _search_closer_on_strip(int lo, int hi, const Point& midpoint,
    const std::vector<Point>& ysorted) {
    std::cout << "in strip for lo = " << lo << " hi = " << hi << std::endl;

    const int strip_width = std::sqrt(dist_between_sq(closest_two_pairs[1]));

    std::vector<Point> stripl, stripr;

    std::copy_if(ysorted.begin() + lo, ysorted.begin() + hi, std::back_inserter(stripl),
        [strip_width, &midpoint](const Point& p) {
            return p.x <= midpoint.x && midpoint.x - p.x < strip_width;
        });

    std::copy_if(ysorted.begin() + lo, ysorted.begin() + hi, std::back_inserter(stripr),
        [strip_width, &midpoint](const Point& p) {
            return p.x > midpoint.x && p.x - midpoint.x < strip_width;
        });

    int stripr_ylow_idx = 0;
    for (const Point& stripl_point : stripl) {
        while (stripr_ylow_idx < int(stripr.size()) &&
            std::abs(stripl_point.y - stripr[stripr_ylow_idx].y) > strip_width) {

            stripr_ylow_idx++; // moving search zone within strip_width of stripl_point
        }

        for (int i = stripr_ylow_idx; i < int(stripr.size()) &&
            std::abs(stripr[i].y - stripl_point.y) <= strip_width; i++) {

            _update_closest_two(stripl_point, stripr[i]);
        }
    }
    std::cout << "strip search complete for lo = " << lo << " hi = " << hi << std::endl;
}

// int _find_median_right(int lo, int hi, const std::vector<Point>& xsorted) {
//     int mid = (lo + hi) / 2;
//     Point midpoint = xsorted[mid];
//     while (mid < hi && xsorted[mid].x == midpoint.x) {
//         mid++;
//     }
//     return mid - 1;
//     return (lo + hi) / 2;
// }

void store_closest_two_pair(int lo, int hi, const std::vector<Point>& xsorted,
    const std::vector<Point>& ysorted) {
    if (hi - lo <= 3) {
        std::cout << "Bruteforce on lo =  " << lo << " hi = " << hi << std::endl;
        _do_bruteforce(lo, hi, xsorted);
    } else {
        std::cout << "Recursing on lo =  " << lo << " hi = " << hi << std::endl;

        int mid = (lo + hi) / 2; // assuming no other point has x same as mid.x

        std::vector<Point> partitioned_y = _partition(lo, hi, xsorted[mid], ysorted);

        store_closest_two_pair(lo, mid + 1, xsorted, partitioned_y);
        store_closest_two_pair(mid + 1, hi, xsorted, partitioned_y);

        _search_closer_on_strip(lo, hi, xsorted[mid], ysorted);
    }
}

void print_results() {
    std::cout << "closest dist " << closest_two_pairs[0][0] << " " << closest_two_pairs[0][1] <<
        " " << Point::dist_between_sq(closest_two_pairs[0][0], closest_two_pairs[0][1]) << std::endl;

    std::cout << "second closest dist " << closest_two_pairs[1][0] << " " << closest_two_pairs[1][1] <<
        " " << Point::dist_between_sq(closest_two_pairs[1][0], closest_two_pairs[1][1]) << std::endl;
}

PointPair find_second_closest_pair(const std::vector<Point>& points) {
    if (points.size() < 3) {
        return PointPair{ points[0], points[1] };
    }

    std::vector<Point> xsorted(points), ysorted(points);

    // presort to maintain monotonic order in array y in linear time in further recursions.
    std::sort(xsorted.begin(), xsorted.end(),
        [](Point& p1, Point& p2) { return p1.x < p2.x; });
    std::sort(ysorted.begin(), ysorted.end(),
        [](Point& p1, Point& p2) { return p1.y < p2.y; });

    // will store in global var instead of returning mins.
    Point temp(UNINITIALIZED, UNINITIALIZED); // marker for uninitialized
    closest_two_pairs[0] = closest_two_pairs[1] = PointPair{ temp, temp };

    store_closest_two_pair(0, points.size(), xsorted, ysorted);

    print_results();

    return closest_two_pairs[1];
}
